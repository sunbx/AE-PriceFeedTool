package controllers

import (
	"PriceFeedTool/models"
	"bytes"
	"encoding/json"
	"fmt"
	"github.com/aeternity/aepp-sdk-go/utils"
	"github.com/astaxie/beego"
	"io"
	"math/big"
	"net/http"
	"strings"
	"time"
)

type MainController struct {
	beego.Controller
}

func (c *MainController) Get() {
	var oct = "ct_2ShJRggE7LZmXPYrz75A7MzjWYpJzGuHkqvktgWL2VabgXf1NU"
	var okt = "ok_2ShJRggE7LZmXPYrz75A7MzjWYpJzGuHkqvktgWL2VabgXf1NU"
	var publicKey = "ak_fUq2NesPXcYZ1CcqBcGC3StpdnQw3iVxMA3YSeCNAwfN4myQk"
	var signingKey = "7c6e602a94f30e4ea7edabe4376314f69ba7eaa2f355ecedb339df847b6f0d80575f81ffb0a297b7725dc671da0b1769b1fc5cbe45385c7b5ad1fc2eaf1d609d"

	fmt.Println("ORACLES QUERIES LIST DATA...")
	response := Get(models.NodeURL + "/v2/oracles/" + okt + "/queries/")
	//解析区块信息为实体
	var oracleQueries OracleQueries
	err := json.Unmarshal([]byte(response), &oracleQueries)
	if err != nil {
		fmt.Println("ORACLES QUERIES LIST DATA", " JSON UNMARSHAL ERROR")
	}
	account, _ := models.SigningKeyHexStringAccount(signingKey)

	fmt.Println("FIND THE DATA WAITING FOR A RESPONSE...")
	for i := 0; i < len(oracleQueries.OracleQueries); i++ {
		fmt.Println("")


		if "or_Xfbg4g==" == oracleQueries.OracleQueries[i].Response {
			fmt.Println("FIND THE DATA WAITING FOR A RESPONSE", " SUCCESS OP-ID : "+oracleQueries.OracleQueries[i].ID)

			fmt.Println("CHECK TO SEE IF IT HAS BEEN RESPONDED")
			s, _, err := models.CallStaticContractFunction(publicKey, oct, "getIsMapPriceExist", []string{oracleQueries.OracleQueries[i].ID, publicKey})

			data, _ := json.Marshal(s)
			if err != nil {
				fmt.Println("CHECK TO SEE IF IT HAS BEEN RESPONDED ERROR")
			}
			if strings.Contains(string(data), publicKey) {
				fmt.Println("CHECK SUCCESS", " HAS THE RESPONSE")
			} else {
				fmt.Println("CHECK SUCCESS", " NO RESPONSE")

				fmt.Println("ACCESS TO MARKET DATA...")
				response := Get("https://api.coingecko.com/api/v3/simple/price?ids=aeternity&vs_currencies=usd")
				var coingecko Coingecko
				err = json.Unmarshal([]byte(response), &coingecko)
				if err != nil {
					fmt.Println("ACCESS TO MARKET DATA API ERROR ", err.Error())
				}
				fmt.Println("OFFER_PRICE ING ...")

				s, e := models.CallContractFunction(account, oct, "offerPrice", []string{oracleQueries.OracleQueries[i].ID, GetRealAebalanceBigInt(coingecko.Aeternity.Usd).String()})
				if e != nil {
					fmt.Println("OFFER_PRICE ERROR : ", e.Error())
				}
				fmt.Println("OFFER_PRICE SUCCESS", s)
			}

			fmt.Println("CHECK IF A RESPONSE IS REQUIRED ")
			s, _, err = models.CallStaticContractFunction(publicKey, oct, "getIsRespondStatus", []string{oracleQueries.OracleQueries[i].ID})
			data, _ = json.Marshal(s)
			if err != nil {
				fmt.Println("CHECK IF A RESPONSE IS REQUIRED - ERROR")
			}
			if strings.Contains(string(data), oracleQueries.OracleQueries[i].ID) {
				s, e := models.CallContractFunction(account, oct, "respond", []string{oracleQueries.OracleQueries[i].ID})
				if e != nil {
					fmt.Println("RESPOND ERROR : ", e.Error())
				}
				fmt.Println("RESPOND SUCCESS", s)
			}
		}

	}
}

type OracleQueries struct {
	OracleQueries []OracleQuery `json:"oracle_queries"`
}
type OracleQuery struct {
	Fee         utils.BigInt `json:"fee"`
	ID          string       `json:"id"`
	OracleID    string       `json:"oracle_id"`
	Query       string       `json:"query"`
	Response    string       `json:"response"`
	ResponseTTL TTL          `json:"response_ttl"`
	SenderID    *string      `json:"sender_id"`
	SenderNonce *uint64      `json:"sender_nonce"`
	TTL         *uint64      `json:"ttl"`
}

type TTL struct {
	Type  string `json:"type"`
	Value uint64 `json:"value"`
}

type Coingecko struct {
	Aeternity Aeternity `json:"aeternity"`
}
type Aeternity struct {
	Usd float64 `json:"usd"`
}

//=======================================
type HuobiAutoGenerated struct {
	Ch     string `json:"ch"`
	Status string `json:"status"`
	Ts     int64  `json:"ts"`
	Tick   Tick   `json:"tick"`
}
type Data struct {
	ID        int64   `json:"id"`
	Ts        int64   `json:"ts"`
	TradeID   int64   `json:"trade-id"`
	Amount    float64 `json:"amount"`
	Price     float64 `json:"price"`
	Direction string  `json:"direction"`
}
type Tick struct {
	ID   int64  `json:"id"`
	Ts   int64  `json:"ts"`
	Data []Data `json:"data"`
}

func Get(url string) (response string) {
	client := http.Client{Timeout: 600 * time.Second}
	resp, error := client.Get(url)
	defer resp.Body.Close()
	if error != nil {
		panic(error)
	}
	var buffer [512]byte
	result := bytes.NewBuffer(nil)
	for {
		n, err := resp.Body.Read(buffer[0:])
		result.Write(buffer[0:n])
		if err != nil && err == io.EOF {
			break
		} else if err != nil {
			panic(err)
		}
	}
	response = result.String()
	return
}

func GetRealAebalanceBigInt(amount float64) *big.Int {
	newFloat := big.NewFloat(amount)
	basefloat := big.NewFloat(1000000000000000000)
	float1 := big.NewFloat(1)
	float1.Mul(newFloat, basefloat)
	resultAmount := new(big.Int)
	float1.Int(resultAmount)
	return resultAmount
}
